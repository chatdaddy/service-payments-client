/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Payments Service
 * Manage ChatDaddy payments
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@chatdaddy.tech
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountPurchase
 */
export interface AccountPurchase {
    /**
     * 
     * @type {string}
     * @memberof AccountPurchase
     */
    'id': string;
    /**
     * The ID of the subscription
     * @type {string}
     * @memberof AccountPurchase
     */
    'subscriptionId': string;
    /**
     * 
     * @type {PurchaseStatus}
     * @memberof AccountPurchase
     */
    'status': PurchaseStatus;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof AccountPurchase
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface ActiveModel
 */
export interface ActiveModel {
    /**
     * Stripe publishable key
     * @type {string}
     * @memberof ActiveModel
     */
    'publishableKey': string;
    /**
     * 
     * @type {Array<Feature>}
     * @memberof ActiveModel
     */
    'features': Array<Feature>;
    /**
     * 
     * @type {ActiveModelLimits}
     * @memberof ActiveModel
     */
    'limits': ActiveModelLimits;
    /**
     * 
     * @type {boolean}
     * @memberof ActiveModel
     */
    'isActivePaidUser': boolean;
}
/**
 * 
 * @export
 * @interface ActiveModelLimits
 */
export interface ActiveModelLimits {
    /**
     * 
     * @type {ActiveModelLimitsMessages}
     * @memberof ActiveModelLimits
     */
    'messages': ActiveModelLimitsMessages;
    /**
     * 
     * @type {boolean}
     * @memberof ActiveModelLimits
     * @deprecated
     */
    'unlimitedMessages': boolean;
    /**
     * 
     * @type {number}
     * @memberof ActiveModelLimits
     */
    'seats': number;
    /**
     * 
     * @type {number}
     * @memberof ActiveModelLimits
     */
    'accounts'?: number;
    /**
     * By default, all buttons have \"Powered By ChatDaddy\".  If this value is true, the user can set no marketing message or their own
     * @type {boolean}
     * @memberof ActiveModelLimits
     */
    'allowCustomMarketingMessage': boolean;
}
/**
 * 
 * @export
 * @interface ActiveModelLimitsMessages
 */
export interface ActiveModelLimitsMessages {
    /**
     * 
     * @type {boolean}
     * @memberof ActiveModelLimitsMessages
     */
    'unlimited': boolean;
    /**
     * maximum messages that can be sent in the current period
     * @type {number}
     * @memberof ActiveModelLimitsMessages
     */
    'limit': number;
    /**
     * messages sent in the period
     * @type {number}
     * @memberof ActiveModelLimitsMessages
     */
    'sent': number;
    /**
     * is chat/message history allowed in the purchased plan
     * @type {boolean}
     * @memberof ActiveModelLimitsMessages
     */
    'historySyncAllowed'?: boolean;
}
/**
 * Purchase/upgrade/downgrade an account. The \"id\" parameter will be used to upgrade/downgrade the account if already purchased
 * @export
 * @interface AutoChargeAccountRequest
 */
export interface AutoChargeAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof AutoChargeAccountRequest
     */
    'type': AutoChargeAccountRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AutoChargeAccountRequest
     */
    'id': string;
    /**
     * 
     * @type {IMAccountTier}
     * @memberof AutoChargeAccountRequest
     */
    'tier': IMAccountTier;
}

/**
    * @export
    * @enum {string}
    */
export enum AutoChargeAccountRequestTypeEnum {
    Account = 'account'
}

/**
 * 
 * @export
 * @interface AutoChargeMessagesRequest
 */
export interface AutoChargeMessagesRequest {
    /**
     * 
     * @type {string}
     * @memberof AutoChargeMessagesRequest
     */
    'type': AutoChargeMessagesRequestTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AutoChargeMessagesRequestTypeEnum {
    Messages = 'messages'
}

/**
 * @type AutoChargeRequest
 * @export
 */
export type AutoChargeRequest = AutoChargeAccountRequest | AutoChargeMessagesRequest;

/**
 * 
 * @export
 * @interface CouponCodeCreateOptions
 */
export interface CouponCodeCreateOptions {
    /**
     * 
     * @type {string}
     * @memberof CouponCodeCreateOptions
     */
    'category': string;
    /**
     * limit coupon code to products
     * @type {Array<string>}
     * @memberof CouponCodeCreateOptions
     */
    'products'?: Array<string>;
    /**
     * set free trial. Can only set using admin access
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'freeTrialDays'?: number;
    /**
     * Add extra days to a subscription. Can only set using admin access
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'extraDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'discountPercentageOff': number;
}
/**
 * @type EligibleModel
 * @export
 */
export type EligibleModel = EligibleModelOneOf | boolean;

/**
 * 
 * @export
 * @interface EligibleModelOneOf
 */
export interface EligibleModelOneOf {
    /**
     * 
     * @type {string}
     * @memberof EligibleModelOneOf
     */
    'reason'?: string;
}
/**
 * List of features
 * @export
 * @enum {string}
 */

export enum Feature {
    TeamInbox = 'team-inbox',
    Audience = 'audience',
    Notifications = 'notifications',
    KeywordReply = 'keyword-reply',
    Broadcast = 'broadcast',
    MessageFlows = 'message-flows'
}

/**
 * Describes the tier of the account, and which features it\'ll have
 * @export
 * @enum {string}
 */

export enum IMAccountTier {
    LimitedMsgNoChatHistory = 'limited_msg_no_chat_history',
    UnlimitedMsgChatHistory = 'unlimited_msg_chat_history'
}

/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject
     */
    'quantity'?: number;
    /**
     * the unique ID of the purchase
     * @type {string}
     * @memberof InlineObject
     */
    'purchaseId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject
     */
    'freeTrial'?: boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof InlineObject
     */
    'expiry'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'status'?: InlineObjectStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject
     */
    'consistent'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObjectStatusEnum {
    Paid = 'paid',
    PendingPayment = 'pending-payment'
}

/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * The new product ID to update to
     * @type {string}
     * @memberof InlineObject1
     */
    'newId': string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<Product>}
     * @memberof InlineResponse200
     */
    'products': Array<Product>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Array<PurchaseDetails>}
     * @memberof InlineResponse2001
     */
    'purchases': Array<PurchaseDetails>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Array<AccountPurchase>}
     * @memberof InlineResponse2002
     */
    'accounts': Array<AccountPurchase>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2003
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    'sessionId': string;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface LimitsModel
 */
export interface LimitsModel {
    /**
     * 
     * @type {LimitsModelMessages}
     * @memberof LimitsModel
     */
    'messages'?: LimitsModelMessages;
    /**
     * 
     * @type {LimitsModelSeats}
     * @memberof LimitsModel
     */
    'seats'?: LimitsModelSeats;
    /**
     * 
     * @type {boolean}
     * @memberof LimitsModel
     */
    'allowCustomMarketingMessage'?: boolean;
    /**
     * 
     * @type {LimitsModelAccounts}
     * @memberof LimitsModel
     */
    'accounts'?: LimitsModelAccounts;
}
/**
 * the number of max IM accounts this user can have
 * @export
 * @interface LimitsModelAccounts
 */
export interface LimitsModelAccounts {
    /**
     * 
     * @type {number}
     * @memberof LimitsModelAccounts
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface LimitsModelMessages
 */
export interface LimitsModelMessages {
    /**
     * -1 means unlimited messages
     * @type {number}
     * @memberof LimitsModelMessages
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof LimitsModelMessages
     */
    'type': LimitsModelMessagesTypeEnum;
    /**
     * is message history sync allowed
     * @type {boolean}
     * @memberof LimitsModelMessages
     */
    'historySyncAllowed'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum LimitsModelMessagesTypeEnum {
    OneTime = 'one-time',
    Monthly = 'monthly'
}

/**
 * 
 * @export
 * @interface LimitsModelSeats
 */
export interface LimitsModelSeats {
    /**
     * 
     * @type {number}
     * @memberof LimitsModelSeats
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof LimitsModelSeats
     */
    'type': LimitsModelSeatsTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum LimitsModelSeatsTypeEnum {
    Total = 'total',
    Additional = 'additional'
}

/**
 * 
 * @export
 * @interface PriceDetails
 */
export interface PriceDetails {
    /**
     * 
     * @type {number}
     * @memberof PriceDetails
     */
    'value': number;
    /**
     * ISO code of currency
     * @type {string}
     * @memberof PriceDetails
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * The category it belongs to (stripe product really)
     * @type {string}
     * @memberof Product
     */
    'categoryId': string;
    /**
     * 
     * @type {PriceDetails}
     * @memberof Product
     */
    'price': PriceDetails;
    /**
     * Whether this product can be actively purchases
     * @type {boolean}
     * @memberof Product
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'priceType': ProductPriceTypeEnum;
    /**
     * 
     * @type {EligibleModel}
     * @memberof Product
     */
    'eligible': EligibleModel;
    /**
     * 
     * @type {Array<PurchaseDetails>}
     * @memberof Product
     */
    'purchases': Array<PurchaseDetails>;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * 
     * @type {LimitsModel}
     * @memberof Product
     */
    'limits': LimitsModel;
    /**
     * 
     * @type {string | Array<Feature>}
     * @memberof Product
     */
    'features': string | Array<Feature>;
    /**
     * 
     * @type {ProductUpdateFreeTrial}
     * @memberof Product
     */
    'freeTrial'?: ProductUpdateFreeTrial | null;
    /**
     * Maximum number of times this product can be bought
     * @type {number}
     * @memberof Product
     */
    'maxLifetimePurchases'?: number | null;
    /**
     * Maximum active purchases of this product
     * @type {number}
     * @memberof Product
     */
    'maxActivePurchases'?: number | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ProductPriceTypeEnum {
    Yearly = 'yearly',
    Monthly = 'monthly',
    OneTime = 'one-time'
}

/**
 * 
 * @export
 * @interface ProductUpdate
 */
export interface ProductUpdate {
    /**
     * 
     * @type {string}
     * @memberof ProductUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {LimitsModel}
     * @memberof ProductUpdate
     */
    'limits'?: LimitsModel;
    /**
     * 
     * @type {string | Array<Feature>}
     * @memberof ProductUpdate
     */
    'features'?: string | Array<Feature>;
    /**
     * 
     * @type {ProductUpdateFreeTrial}
     * @memberof ProductUpdate
     */
    'freeTrial'?: ProductUpdateFreeTrial | null;
    /**
     * Whether this product can be actively purchases
     * @type {boolean}
     * @memberof ProductUpdate
     */
    'active'?: boolean;
    /**
     * Maximum number of times this product can be bought
     * @type {number}
     * @memberof ProductUpdate
     */
    'maxLifetimePurchases'?: number | null;
    /**
     * Maximum active purchases of this product
     * @type {number}
     * @memberof ProductUpdate
     */
    'maxActivePurchases'?: number | null;
}
/**
 * 
 * @export
 * @interface ProductUpdateFreeTrial
 */
export interface ProductUpdateFreeTrial {
    /**
     * 
     * @type {number}
     * @memberof ProductUpdateFreeTrial
     */
    'days': number;
    /**
     * 
     * @type {EligibleModel}
     * @memberof ProductUpdateFreeTrial
     */
    'eligible'?: EligibleModel;
}
/**
 * Info about the purchase if applicable
 * @export
 * @interface PurchaseDetails
 */
export interface PurchaseDetails {
    /**
     * ID of the purchase
     * @type {string}
     * @memberof PurchaseDetails
     */
    'id': string;
    /**
     * ID of the product purchased
     * @type {string}
     * @memberof PurchaseDetails
     */
    'productId': string;
    /**
     * The team who purchased it
     * @type {string}
     * @memberof PurchaseDetails
     */
    'teamId': string;
    /**
     * ID of the user who purchased it
     * @type {string}
     * @memberof PurchaseDetails
     */
    'userId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PurchaseDetails
     */
    'date': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PurchaseDetails
     */
    'expiry'?: string;
    /**
     * 
     * @type {PriceDetails}
     * @memberof PurchaseDetails
     */
    'price': PriceDetails;
    /**
     * 
     * @type {PurchaseDetailsTrial}
     * @memberof PurchaseDetails
     */
    'trial'?: PurchaseDetailsTrial | null;
    /**
     * 
     * @type {PurchaseStatus}
     * @memberof PurchaseDetails
     */
    'status'?: PurchaseStatus;
    /**
     * 
     * @type {PurchaseDetailsStripe}
     * @memberof PurchaseDetails
     */
    'stripe'?: PurchaseDetailsStripe | null;
}
/**
 * 
 * @export
 * @interface PurchaseDetailsStripe
 */
export interface PurchaseDetailsStripe {
    /**
     * 
     * @type {string}
     * @memberof PurchaseDetailsStripe
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseDetailsStripe
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseDetailsStripe
     */
    'subscriptionId'?: string;
}
/**
 * 
 * @export
 * @interface PurchaseDetailsTrial
 */
export interface PurchaseDetailsTrial {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PurchaseDetailsTrial
     */
    'expiry'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum PurchaseStatus {
    Paid = 'paid',
    Cancelled = 'cancelled',
    PendingPayment = 'pending-payment',
    Voided = 'voided'
}

/**
 * 
 * @export
 * @interface ReferralCodeData
 */
export interface ReferralCodeData {
    /**
     * 
     * @type {string}
     * @memberof ReferralCodeData
     */
    'code': string;
    /**
     * 
     * @type {PriceDetails}
     * @memberof ReferralCodeData
     */
    'credit': PriceDetails;
}
/**
 * 
 * @export
 * @interface SessionCreateOptions
 */
export interface SessionCreateOptions {
    /**
     * 
     * @type {string}
     * @memberof SessionCreateOptions
     */
    'coupon'?: string;
    /**
     * 
     * @type {Array<SessionCreateOptionsProducts>}
     * @memberof SessionCreateOptions
     */
    'products': Array<SessionCreateOptionsProducts>;
    /**
     * set free trial. Can only set using admin access
     * @type {number}
     * @memberof SessionCreateOptions
     */
    'freeTrialDays'?: number;
    /**
     * Add extra days to a subscription. Can only set using admin access
     * @type {number}
     * @memberof SessionCreateOptions
     */
    'extraDays'?: number;
    /**
     * 
     * @type {SessionCreateOptionsCallbackUrls}
     * @memberof SessionCreateOptions
     */
    'callbackUrls': SessionCreateOptionsCallbackUrls;
}
/**
 * 
 * @export
 * @interface SessionCreateOptionsCallbackUrls
 */
export interface SessionCreateOptionsCallbackUrls {
    /**
     * 
     * @type {string}
     * @memberof SessionCreateOptionsCallbackUrls
     */
    'success': string;
    /**
     * 
     * @type {string}
     * @memberof SessionCreateOptionsCallbackUrls
     */
    'failure': string;
}
/**
 * 
 * @export
 * @interface SessionCreateOptionsProducts
 */
export interface SessionCreateOptionsProducts {
    /**
     * 
     * @type {string}
     * @memberof SessionCreateOptionsProducts
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof SessionCreateOptionsProducts
     */
    'quantity'?: number;
}

/**
 * CouponCodesApi - axios parameter creator
 * @export
 */
export const CouponCodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate a coupon code
         * @param {CouponCodeCreateOptions} [couponCodeCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsPost: async (couponCodeCreateOptions?: CouponCodeCreateOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(couponCodeCreateOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CouponCodesApi - functional programming interface
 * @export
 */
export const CouponCodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CouponCodesApiAxiosParamCreator(configuration)
    return {
        /**
         * Generate a coupon code
         * @param {CouponCodeCreateOptions} [couponCodeCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsPost(couponCodeCreateOptions?: CouponCodeCreateOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsPost(couponCodeCreateOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CouponCodesApi - factory interface
 * @export
 */
export const CouponCodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CouponCodesApiFp(configuration)
    return {
        /**
         * Generate a coupon code
         * @param {CouponCodeCreateOptions} [couponCodeCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsPost(couponCodeCreateOptions?: CouponCodeCreateOptions, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.couponsPost(couponCodeCreateOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CouponCodesApi - object-oriented interface
 * @export
 * @class CouponCodesApi
 * @extends {BaseAPI}
 */
export class CouponCodesApi extends BaseAPI {
    /**
     * Generate a coupon code
     * @param {CouponCodeCreateOptions} [couponCodeCreateOptions] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponCodesApi
     */
    public couponsPost(couponCodeCreateOptions?: CouponCodeCreateOptions, options?: AxiosRequestConfig) {
        return CouponCodesApiFp(this.configuration).couponsPost(couponCodeCreateOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Most properties can be updated from here.  However, some properties require the Stripe dashboard, these properties are: - id - price - categoryId - active (if stripe produce is inactive, then the DB will reflect the same) 
         * @summary Update a product\'s properties
         * @param {string} id 
         * @param {ProductUpdate} [productUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPatch: async (id: string, productUpdate?: ProductUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsPatch', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sync products with stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsSync: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Most properties can be updated from here.  However, some properties require the Stripe dashboard, these properties are: - id - price - categoryId - active (if stripe produce is inactive, then the DB will reflect the same) 
         * @summary Update a product\'s properties
         * @param {string} id 
         * @param {ProductUpdate} [productUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsPatch(id: string, productUpdate?: ProductUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsPatch(id, productUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sync products with stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsSync(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsSync(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.productsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Most properties can be updated from here.  However, some properties require the Stripe dashboard, these properties are: - id - price - categoryId - active (if stripe produce is inactive, then the DB will reflect the same) 
         * @summary Update a product\'s properties
         * @param {string} id 
         * @param {ProductUpdate} [productUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPatch(id: string, productUpdate?: ProductUpdate, options?: any): AxiosPromise<Product> {
            return localVarFp.productsPatch(id, productUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sync products with stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsSync(options?: any): AxiosPromise<void> {
            return localVarFp.productsSync(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * 
     * @summary Get all products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsGet(options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Most properties can be updated from here.  However, some properties require the Stripe dashboard, these properties are: - id - price - categoryId - active (if stripe produce is inactive, then the DB will reflect the same) 
     * @summary Update a product\'s properties
     * @param {string} id 
     * @param {ProductUpdate} [productUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsPatch(id: string, productUpdate?: ProductUpdate, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsPatch(id, productUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sync products with stripe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsSync(options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsSync(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PurchasesApi - axios parameter creator
 * @export
 */
export const PurchasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the list of active features & limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/purchases/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel a subscription
         * @param {string} purchaseId The purchase id to update
         * @param {boolean} [voidPurchase] If true, the subscription is voided and the features are removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainDelete: async (purchaseId: string, voidPurchase?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseId' is not null or undefined
            assertParamExists('mainDelete', 'purchaseId', purchaseId)
            const localVarPath = `/purchases/{purchaseId}`
                .replace(`{${"purchaseId"}}`, encodeURIComponent(String(purchaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)

            if (voidPurchase !== undefined) {
                localVarQueryParameter['voidPurchase'] = voidPurchase;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of products, active subscriptions, and other metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/purchases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ", "PAYMENTS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Method will update the underlying stripe subscription of the specified purchase ID
         * @summary Upgrade/Downgrade a Subscription
         * @param {string} purchaseId The purchase id to update
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainPatch: async (purchaseId: string, inlineObject1?: InlineObject1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseId' is not null or undefined
            assertParamExists('mainPatch', 'purchaseId', purchaseId)
            const localVarPath = `/purchases/{purchaseId}`
                .replace(`{${"purchaseId"}}`, encodeURIComponent(String(purchaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchase a product
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainPost: async (inlineObject?: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/purchases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe  and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainRefresh: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/purchases/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of accounts purchased via the \"auto-charge\" API
         * @param {string} [id] 
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasedAccountsGet: async (id?: string, count?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/purchases/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ", "PAYMENTS_UPDATE"], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all purchases
         * @param {boolean} [onlyValid] If true, only unexpired &amp; active purchases will be sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasesGet: async (onlyValid?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/purchases/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ", "PAYMENTS_UPDATE"], configuration)

            if (onlyValid !== undefined) {
                localVarQueryParameter['onlyValid'] = onlyValid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PurchasesApi - functional programming interface
 * @export
 */
export const PurchasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PurchasesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the list of active features & limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancel a subscription
         * @param {string} purchaseId The purchase id to update
         * @param {boolean} [voidPurchase] If true, the subscription is voided and the features are removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mainDelete(purchaseId: string, voidPurchase?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mainDelete(purchaseId, voidPurchase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of products, active subscriptions, and other metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mainGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mainGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Method will update the underlying stripe subscription of the specified purchase ID
         * @summary Upgrade/Downgrade a Subscription
         * @param {string} purchaseId The purchase id to update
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mainPatch(purchaseId: string, inlineObject1?: InlineObject1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mainPatch(purchaseId, inlineObject1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purchase a product
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mainPost(inlineObject?: InlineObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mainPost(inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe  and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mainRefresh(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mainRefresh(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of accounts purchased via the \"auto-charge\" API
         * @param {string} [id] 
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchasedAccountsGet(id?: string, count?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchasedAccountsGet(id, count, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of all purchases
         * @param {boolean} [onlyValid] If true, only unexpired &amp; active purchases will be sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchasesGet(onlyValid?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchasesGet(onlyValid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PurchasesApi - factory interface
 * @export
 */
export const PurchasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PurchasesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the list of active features & limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeGet(options?: any): AxiosPromise<ActiveModel> {
            return localVarFp.activeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel a subscription
         * @param {string} purchaseId The purchase id to update
         * @param {boolean} [voidPurchase] If true, the subscription is voided and the features are removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainDelete(purchaseId: string, voidPurchase?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.mainDelete(purchaseId, voidPurchase, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of products, active subscriptions, and other metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainGet(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.mainGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Method will update the underlying stripe subscription of the specified purchase ID
         * @summary Upgrade/Downgrade a Subscription
         * @param {string} purchaseId The purchase id to update
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainPatch(purchaseId: string, inlineObject1?: InlineObject1, options?: any): AxiosPromise<void> {
            return localVarFp.mainPatch(purchaseId, inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purchase a product
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainPost(inlineObject?: InlineObject, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.mainPost(inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe  and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainRefresh(options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.mainRefresh(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of accounts purchased via the \"auto-charge\" API
         * @param {string} [id] 
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasedAccountsGet(id?: string, count?: number, page?: number, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.purchasedAccountsGet(id, count, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of all purchases
         * @param {boolean} [onlyValid] If true, only unexpired &amp; active purchases will be sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasesGet(onlyValid?: boolean, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.purchasesGet(onlyValid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PurchasesApi - object-oriented interface
 * @export
 * @class PurchasesApi
 * @extends {BaseAPI}
 */
export class PurchasesApi extends BaseAPI {
    /**
     * 
     * @summary Get the list of active features & limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public activeGet(options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).activeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel a subscription
     * @param {string} purchaseId The purchase id to update
     * @param {boolean} [voidPurchase] If true, the subscription is voided and the features are removed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public mainDelete(purchaseId: string, voidPurchase?: boolean, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).mainDelete(purchaseId, voidPurchase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of products, active subscriptions, and other metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public mainGet(options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).mainGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Method will update the underlying stripe subscription of the specified purchase ID
     * @summary Upgrade/Downgrade a Subscription
     * @param {string} purchaseId The purchase id to update
     * @param {InlineObject1} [inlineObject1] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public mainPatch(purchaseId: string, inlineObject1?: InlineObject1, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).mainPatch(purchaseId, inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purchase a product
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public mainPost(inlineObject?: InlineObject, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).mainPost(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches the list of active subscriptions/purchases from stripe  and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
     * @summary Refreshes the subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public mainRefresh(options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).mainRefresh(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of accounts purchased via the \"auto-charge\" API
     * @param {string} [id] 
     * @param {number} [count] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public purchasedAccountsGet(id?: string, count?: number, page?: number, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).purchasedAccountsGet(id, count, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of all purchases
     * @param {boolean} [onlyValid] If true, only unexpired &amp; active purchases will be sent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public purchasesGet(onlyValid?: boolean, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).purchasesGet(onlyValid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReferralsApi - axios parameter creator
 * @export
 */
export const ReferralsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referralsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/referrals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referralsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/referrals/apply-credit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["REFERRAL_APPLY_CREDIT"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralsApi - functional programming interface
 * @export
 */
export const ReferralsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async referralsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferralCodeData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.referralsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async referralsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.referralsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReferralsApi - factory interface
 * @export
 */
export const ReferralsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referralsGet(options?: any): AxiosPromise<ReferralCodeData> {
            return localVarFp.referralsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referralsPost(options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.referralsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferralsApi - object-oriented interface
 * @export
 * @class ReferralsApi
 * @extends {BaseAPI}
 */
export class ReferralsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public referralsGet(options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).referralsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public referralsPost(options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).referralsPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Payment method must be added to the Stripe portal for auto-charging to work
         * @summary Auto charge without a checkout session to get a standard product
         * @param {string} [coupon] 
         * @param {AutoChargeRequest} [autoChargeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoCharge: async (coupon?: string, autoChargeRequest?: AutoChargeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auto-charge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)

            if (coupon !== undefined) {
                localVarQueryParameter['coupon'] = coupon;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoChargeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {string} returnUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingSessionPost: async (returnUrl: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'returnUrl' is not null or undefined
            assertParamExists('billingSessionPost', 'returnUrl', returnUrl)
            const localVarPath = `/billing-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new stripe session
         * @param {SessionCreateOptions} [sessionCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPost: async (sessionCreateOptions?: SessionCreateOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sessionCreateOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Receive stripe hook
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeHook: async (requestBody?: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe-hook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication stripe required
            await setApiKeyToObject(localVarHeaderParameter, "stripe-signature", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration)
    return {
        /**
         * Payment method must be added to the Stripe portal for auto-charging to work
         * @summary Auto charge without a checkout session to get a standard product
         * @param {string} [coupon] 
         * @param {AutoChargeRequest} [autoChargeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoCharge(coupon?: string, autoChargeRequest?: AutoChargeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoCharge(coupon, autoChargeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {string} returnUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingSessionPost(returnUrl: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingSessionPost(returnUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new stripe session
         * @param {SessionCreateOptions} [sessionCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionPost(sessionCreateOptions?: SessionCreateOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionPost(sessionCreateOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Receive stripe hook
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeHook(requestBody?: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripeHook(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeApiFp(configuration)
    return {
        /**
         * Payment method must be added to the Stripe portal for auto-charging to work
         * @summary Auto charge without a checkout session to get a standard product
         * @param {string} [coupon] 
         * @param {AutoChargeRequest} [autoChargeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoCharge(coupon?: string, autoChargeRequest?: AutoChargeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.autoCharge(coupon, autoChargeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {string} returnUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingSessionPost(returnUrl: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.billingSessionPost(returnUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new stripe session
         * @param {SessionCreateOptions} [sessionCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPost(sessionCreateOptions?: SessionCreateOptions, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.sessionPost(sessionCreateOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Receive stripe hook
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeHook(requestBody?: { [key: string]: any; }, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.stripeHook(requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     * Payment method must be added to the Stripe portal for auto-charging to work
     * @summary Auto charge without a checkout session to get a standard product
     * @param {string} [coupon] 
     * @param {AutoChargeRequest} [autoChargeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public autoCharge(coupon?: string, autoChargeRequest?: AutoChargeRequest, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).autoCharge(coupon, autoChargeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new billing portal session to manage payment details
     * @param {string} returnUrl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public billingSessionPost(returnUrl: string, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).billingSessionPost(returnUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new stripe session
     * @param {SessionCreateOptions} [sessionCreateOptions] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public sessionPost(sessionCreateOptions?: SessionCreateOptions, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).sessionPost(sessionCreateOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Receive stripe hook
     * @param {{ [key: string]: any; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public stripeHook(requestBody?: { [key: string]: any; }, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).stripeHook(requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


